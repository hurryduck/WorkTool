<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />

        <title>work tool</title>

        <style>
            .view {
                display: none;
            }

            .view.display {
                display: block;
            }
        </style>

        <script src="https://cdnjs.cloudflare.com/ajax/libs/jsSHA/2.4.2/sha.js"></script>
    </head>

    <body>
        <header>
            <h1>Work Tool</h1>
        </header>

        <main id="app">
            <section id="login_view" class="view">
                <h2>Login</h2>

                <form id="login_form">
                    <label>
                        username:
                        <input type="text" name="username" required />
                    </label>
                    <label>
                        password:
                        <input type="password" name="password" required />
                    </label>
                    <button type="submit">login</button>
                </form>
            </section>
        </main>

        <footer></footer>

        <script>
            const SECOND = 1;
            const MINUTE = SECOND * 60;
            const HOUR = MINUTE * 60;
            const DAY = HOUR * 24;

            class EncodingUtils {
                static base32ToHex(value) {
                    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567';
                    let bits = '';
                    let hex = '';

                    const normalized = value.replace(/=+$/g, '').toUpperCase();

                    for (let i = 0; i < normalized.length; i++) {
                        const index = chars.indexOf(normalized[i]);

                        if (index === -1) {
                            return null;
                        }

                        bits += index.toString(2).padStart(5, '0');
                    }

                    for (let i = 0; i + 4 <= bits.length; i += 4) {
                        hex += parseInt(bits.slice(i, i + 4), 2).toString(16);
                    }

                    return hex;
                }
            }

            class CookieUtils {
                static get(name) {
                    if (typeof name !== 'string' || name.trim() === '') {
                        return null;
                    }

                    const encodedName = encodeURIComponent(name);
                    const cookie = `; ${document.cookie}`;
                    const value = cookie.split(`; ${encodedName}=`);

                    if (value.length === 2) {
                        return decodeURIComponent(value[1].split(';')[0]);
                    }

                    return null;
                }

                /**
                 * @param {string} name
                 * @param {string} value
                 * @param {number} expires - seconds
                 */
                static set(name, value, expires) {
                    if (typeof name !== 'string' || name.trim() === '') {
                        return;
                    }

                    if (value === null || value === undefined) {
                        return;
                    }

                    if (typeof expires !== 'number' || expires < 0) {
                        return;
                    }

                    const encodedName = encodeURIComponent(name);
                    const encodedValue = encodeURIComponent(String(value));

                    document.cookie = `${encodedName}=${encodedValue}; max-age=${expires}; path=/; Secure; SameSite=None`;
                }
            }

            class JsShaAdapter {
                hash(text) {
                    const shaObj = new jsSHA('SHA-256', 'TEXT');

                    shaObj.update(text);

                    return shaObj.getHash('HEX');
                }
            }

            class Database {
                static NAME = 'work_tool_db';
                static VERSION = 1;
                static STORES = {
                    USER: 'user',
                    SESSION: 'session',
                };
                static STORE_CONFIG = {
                    [Database.STORES.USER]: { keyPath: 'id' },
                    [Database.STORES.SESSION]: { keyPath: 'id' },
                };

                constructor() {
                    this.db = null;
                }

                async setup() {
                    this.db = await this._open();
                }

                _open() {
                    return new Promise((resolve, reject) => {
                        const request = indexedDB.open(Database.NAME, Database.VERSION);

                        request.onupgradeneeded = (event) => {
                            const db = event.target.result;

                            for (const storeName of Object.values(Database.STORES)) {
                                if (!db.objectStoreNames.contains(storeName)) {
                                    db.createObjectStore(storeName, Database.STORE_CONFIG[storeName]);
                                }
                            }
                        };

                        request.onsuccess = (event) => {
                            resolve(event.target.result);
                        };

                        request.onerror = () => {
                            reject(request.error);
                        };

                        request.onblocked = () => {
                            reject(new Error('IndexedDB open blocked'));
                        };
                    });
                }

                select(storeName, key) {
                    return new Promise((resolve, reject) => {
                        const transaction = this.db.transaction(storeName, 'readonly');
                        const store = transaction.objectStore(storeName);

                        let request;

                        if (key == null) {
                            request = store.getAll();
                        } else {
                            request = store.get(key);
                        }

                        request.onsuccess = () => {
                            resolve(request.result);
                        };

                        request.onerror = () => {
                            reject(request.error);
                        };

                        transaction.onerror = () => {
                            reject(transaction.error);
                        };

                        transaction.onabort = () => {
                            reject(transaction.error);
                        };
                    });
                }

                update(storeName, value) {
                    return new Promise((resolve, reject) => {
                        const transaction = this.db.transaction(storeName, 'readwrite');
                        const store = transaction.objectStore(storeName);

                        const request = store.put(value);

                        request.onerror = () => {
                            reject(request.error);
                        };

                        transaction.oncomplete = () => {
                            resolve(true);
                        };

                        transaction.onerror = () => {
                            reject(transaction.error);
                        };

                        transaction.onabort = () => {
                            reject(transaction.error);
                        };
                    });
                }

                delete(storeName, key) {
                    return new Promise((resolve, reject) => {
                        const transaction = this.db.transaction(storeName, 'readwrite');
                        const store = transaction.objectStore(storeName);

                        const request = store.delete(key);

                        request.onerror = () => {
                            reject(request.error);
                        };

                        transaction.oncomplete = () => {
                            resolve(true);
                        };

                        transaction.onerror = () => {
                            reject(transaction.error);
                        };

                        transaction.onabort = () => {
                            reject(transaction.error);
                        };
                    });
                }

                close() {
                    if (this.db !== null) {
                        this.db.close();
                    }

                    this.db = null;
                }
            }

            class EntityBase {
                constructor(key) {
                    if (typeof key !== 'string' || key.trim() === '') {
                        throw new Error('invalid key');
                    }

                    this.key = key;
                }
            }

            class UserEntity extends EntityBase {
                constructor(key, params) {
                    super(key);

                    this.username = params?.username ?? {};
                }
            }

            class SessionEntity extends EntityBase {
                constructor(key, params) {
                    super(key);

                    /** @type {number|null} 만료 시간 (단위: ms) */
                    this.expires = params?.expires ?? null;
                }

                isValid(now) {
                    if (this.expires === null) {
                        return false;
                    }

                    const isExpires = now > this.expires;

                    return !isExpires;
                }

                getKey() {
                    return this.key;
                }

                getExpires() {
                    return this.expires;
                }

                toObject() {
                    return {
                        id: this.key,
                        expires: this.expires,
                    };
                }
            }

            class IService {
                constructor() {
                    if (new.target === IService) {
                        throw new Error('abstract');
                    }
                }
            }

            class CryptoService extends IService {
                constructor(dependency) {
                    super();

                    /** @type {JsShaAdapter} */
                    this.hashAdapter = dependency.hashAdapter;
                }

                hash(text) {
                    return this.hashAdapter.hash(text);
                }
            }

            class UserService extends IService {
                constructor(dependency) {
                    super();

                    /** @type {Database} */
                    this.database = dependency.database;
                    /** @type {CryptoService} */
                    this.cryptoService = dependency.cryptoService;
                }

                async register(username, password) {
                    const userId = this._createUserId(username, password);
                    const newUser = new UserEntity(userId, { username });

                    const result = await this.database.update(Database.STORES.USER, newUser);

                    return newUser;
                }

                async isUser(username, password) {
                    const userId = this._createUserId(username, password);
                    const user = await this.database.select(Database.STORES.USER, userId);

                    return Boolean(user);
                }

                async getUser(username, password) {
                    const userId = this._createUserId(username, password);

                    const user = await this.database.select(Database.STORES.USER, userId);

                    return user;
                }

                _createUserId(username, password) {
                    const text = `${username}:${password}`;
                    const hash = this.cryptoService.hash(text);

                    return hash;
                }
            }

            class SessionService extends IService {
                static SESSION_COOKIE = 'session';
                static SESSION_COOKIE_EXPRISE = 12 * HOUR;

                constructor(dependency) {
                    super();

                    /** @type {Database} */
                    this.database = dependency.database;
                    /** @type {CryptoService} */
                    this.cryptoService = dependency.cryptoService;
                    /** @type {UserService} */
                    this.userService = dependency.userService;
                }

                async create(username) {
                    const text = `${username}:${Date.now()}`;
                    const hash = this.cryptoService.hash(text);

                    /** @type {SessionEntity} */
                    const session = new SessionEntity(hash, {
                        expires: Date.now() + SessionService.SESSION_COOKIE_EXPRISE * 1000,
                    });

                    CookieUtils.set(SessionService.SESSION_COOKIE, session.getKey(), SessionService.SESSION_COOKIE_EXPRISE);

                    await this.database.update(Database.STORES.SESSION, session.toObject());
                }

                async get() {
                    const sessionId = CookieUtils.get(SessionService.SESSION_COOKIE);

                    if (!sessionId) {
                        return null;
                    }

                    const stored = await this.database.select(Database.STORES.SESSION, sessionId);
                    const session = new SessionEntity(sessionId, stored);

                    return session;
                }
            }

            class AuthenticationService extends IService {
                constructor(dependency) {
                    super();

                    /** @type {Database} */
                    this.database = dependency.database;
                    /** @type {UserService} */
                    this.userService = dependency.userService;
                    /** @type {SessionService} */
                    this.sessionService = dependency.sessionService;
                }

                async isLogin() {
                    /** @type {SessionEntity} */
                    const session = await this.sessionService.get();

                    if (session == null || !session.isValid(Date.now())) {
                        return false;
                    }

                    return true;
                }

                login(username, password) {
                    const isUser = this.userService.isUser(username, password);

                    if (!isUser) {
                        this.userService.register(username, password);
                    }

                    this.sessionService.create(username);

                    return true;
                }
            }

            class ViewManager {
                constructor(dependency) {
                    this.views = new Map();
                    this.state = {};

                    this.views.set('login', dependency.loginView);
                }

                async render() {
                    await this._setup();
                    this.update();
                }

                async _setup() {
                    const queue = [];

                    for (const view of this.views.values()) {
                        const setupPromise = view.setup({
                            root: this,
                        });

                        queue.push(setupPromise);
                    }

                    await Promise.all(queue);
                }

                update() {
                    for (const view of this.views.values()) {
                        view.render();
                    }
                }

                getState() {
                    return this.state;
                }
            }

            class IView {
                constructor() {
                    if (new.target === IView) {
                        throw new Error('abstract');
                    }
                }

                async setup(root) {
                    throw new Error('setup required');
                }

                render() {
                    throw new Error('render required');
                }
            }

            class LoginView extends IView {
                constructor(dependency) {
                    super(dependency);

                    /** @type {AuthenticationService} */
                    this.authenticationService = dependency.authenticationService;

                    this.rootEl = document.querySelector('#login_view');
                    this.loginFormEl = document.querySelector('#login_form');

                    /** @type {ViewManager} */
                    this.root = null;
                    this.state = {};
                }

                async setup(params) {
                    this.root = params.root;
                    this.state = this.root.getState();

                    await this._setupState();
                    this._bindEvent();
                }

                async _setupState() {
                    this.state.isLogin = await this.authenticationService.isLogin();
                }

                _bindEvent() {
                    this.loginFormEl.addEventListener('submit', this._handleLogin.bind(this));
                }

                _handleLogin(event) {
                    event.preventDefault();

                    const formData = new FormData(event.target);

                    const username = formData.get('username');
                    const password = formData.get('password');

                    const result = this.authenticationService.login(username, password);

                    if (result) {
                        this.state.isLogin = true;

                        this.root.update();
                    } else {
                        alert('login failed');
                    }
                }

                render() {
                    if (this.state.isLogin) {
                        this.rootEl.classList.remove('display');
                    } else {
                        this.rootEl.classList.add('display');
                    }
                }
            }

            class DIManager {
                constructor(dependency) {
                    /** @type {DIContainer} */
                    this.di = dependency.di;
                }

                setup() {
                    this.di.register('JsShaAdapter', new JsShaAdapter());
                    this.di.register('Database', new Database());

                    this.di.register(
                        'CryptoService',
                        new CryptoService({
                            hashAdapter: this.di.get('JsShaAdapter'),
                        })
                    );
                    this.di.register(
                        'UserService',
                        new UserService({
                            database: this.di.get('Database'),
                            cryptoService: this.di.get('CryptoService'),
                        })
                    );
                    this.di.register(
                        'SessionService',
                        new SessionService({
                            database: this.di.get('Database'),
                            cryptoService: this.di.get('CryptoService'),
                            userService: this.di.get('UserService'),
                        })
                    );
                    this.di.register(
                        'AuthenticationService',
                        new AuthenticationService({
                            database: this.di.get('Database'),
                            userService: this.di.get('UserService'),
                            sessionService: this.di.get('SessionService'),
                        })
                    );

                    this.di.register(
                        'LoginView',
                        new LoginView({
                            authenticationService: this.di.get('AuthenticationService'),
                        })
                    );
                    this.di.register(
                        'ViewManager',
                        new ViewManager({
                            loginView: this.di.get('LoginView'),
                        })
                    );
                }
            }

            class DIContainer {
                constructor() {
                    this.dependencies = new Map();
                }

                register(name, instance) {
                    if (this.dependencies.has(name)) {
                        return this.dependencies.get(name);
                    }

                    this.dependencies.set(name, instance);

                    return instance;
                }

                get(name) {
                    if (!this.dependencies.has(name)) {
                        throw new Error(`[DIContainer] ${name}을 찾을 수 없습니다.`);
                    }

                    return this.dependencies.get(name);
                }
            }

            class App {
                constructor() {
                    this.di = new DIContainer();
                    this.diManager = new DIManager({ di: this.di });
                }

                async run() {
                    await this._setup();

                    /** @type {ViewManager} */
                    const viewManager = this.di.get('ViewManager');

                    viewManager.render();
                }

                async _setup() {
                    this.diManager.setup();

                    await this._setupDatabase();
                    this._setupView();
                }

                async _setupDatabase() {
                    /** @type {Database} */
                    const database = this.di.get('Database');

                    await database.setup();
                }

                _setupView() {}
            }

            const app = new App();

            app.run();
        </script>
    </body>
</html>
