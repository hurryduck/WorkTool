<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />

        <title>work tool</title>

        <style>
            .view {
                display: none;
            }

            .view.display {
                display: block;
            }
        </style>

        <script src="https://cdnjs.cloudflare.com/ajax/libs/jsSHA/2.4.2/sha.js"></script>
    </head>

    <body>
        <header>
            <h1>Work Tool</h1>
        </header>

        <main id="app">
            <section id="login_view" class="view">
                <h2>Login</h2>

                <form id="login_form">
                    <label>
                        username:
                        <input type="text" name="username" required />
                    </label>
                    <label>
                        password:
                        <input type="password" name="password" required />
                    </label>
                    <button type="submit">login</button>
                </form>
            </section>
        </main>

        <footer></footer>

        <script>
            const config = {};
            const utils = {};
            const libs = {};

            class Database {
                static NAME = 'work_tool_db';
                static VERSION = 1;
                static STORES = {
                    USER: 'user',
                    SESSION: 'session',
                };
                static STORE_CONFIG = {
                    [this.STORES.USER]: { keyPath: 'id' },
                    [this.STORES.SESSION]: { keyPath: 'id' },
                };

                constructor() {
                    this.db = null;
                }

                async init() {
                    this.db = await this.open();
                    return this.db;
                }

                open() {
                    return new Promise((resolve, reject) => {
                        const request = indexedDB.open(Database.NAME, Database.VERSION);

                        request.onupgradeneeded = (event) => {
                            const db = event.target.result;

                            for (const storeName of Object.values(Database.STORES)) {
                                if (!db.objectStoreNames.contains(storeName)) {
                                    db.createObjectStore(storeName, Database.STORE_CONFIG[storeName]);
                                }
                            }
                        };

                        request.onsuccess = (event) => {
                            resolve(event.target.result);
                        };

                        request.onerror = () => {
                            reject(request.error);
                        };

                        request.onblocked = () => {
                            reject(new Error('IndexedDB open blocked'));
                        };
                    });
                }

                select(storeName, key) {
                    return new Promise((resolve, reject) => {
                        const transaction = this.db.transaction(storeName, 'readonly');
                        const store = transaction.objectStore(storeName);

                        let request;

                        if (key == null) {
                            request = store.getAll();
                        } else {
                            request = store.get(key);
                        }

                        request.onsuccess = () => {
                            resolve(request.result);
                        };

                        request.onerror = () => {
                            reject(request.error);
                        };

                        transaction.onerror = () => {
                            reject(transaction.error);
                        };

                        transaction.onabort = () => {
                            reject(transaction.error);
                        };
                    });
                }

                update(storeName, value) {
                    return new Promise((resolve, reject) => {
                        const transaction = this.db.transaction(storeName, 'readwrite');
                        const store = transaction.objectStore(storeName);

                        const request = store.put(value);

                        request.onerror = () => {
                            reject(request.error);
                        };

                        transaction.oncomplete = () => {
                            resolve(true);
                        };

                        transaction.onerror = () => {
                            reject(transaction.error);
                        };

                        transaction.onabort = () => {
                            reject(transaction.error);
                        };
                    });
                }

                delete(storeName, key) {
                    return new Promise((resolve, reject) => {
                        const transaction = this.db.transaction(storeName, 'readwrite');
                        const store = transaction.objectStore(storeName);

                        const request = store.delete(key);

                        request.onerror = () => {
                            reject(request.error);
                        };

                        transaction.oncomplete = () => {
                            resolve(true);
                        };

                        transaction.onerror = () => {
                            reject(transaction.error);
                        };

                        transaction.onabort = () => {
                            reject(transaction.error);
                        };
                    });
                }

                close() {
                    if (this.db !== null) {
                        this.db.close();
                    }

                    this.db = null;
                }
            }

            class EntityBase {
                constructor(key) {
                    if (typeof key !== 'string' || key.trim() === '') {
                        throw new Error('invalid key');
                    }

                    this.key = key;
                }
            }

            class UserEntity extends EntityBase {
                constructor(key, params) {
                    super(key);

                    const { username } = params ?? {};

                    this.username = username;
                }
            }

            class SessionEntity extends EntityBase {
                constructor(key, params) {
                    super(key);

                    const { isDeleted, expires } = params ?? {};

                    this.isDeleted = isDeleted ?? false;
                    this.expires = expires ?? null; // ms
                }

                isValid(now) {
                    if (this.isDeleted === true) {
                        return false;
                    }

                    if (this.expires === null) {
                        return false;
                    }

                    const isExpires = now > this.expires;

                    return !isExpires;
                }

                delete() {
                    this.isDeleted = true;
                }
            }

            class ServiceManager {
                static SERVICES = {
                    AUTHENTICATION: 'authentication',
                    USER: 'user',
                };

                constructor(dependency) {
                    const { database } = dependency ?? {};

                    this.database = database;

                    this.userService = new UserService({ database: this.database });
                    this.sessionService = new SessionService({ database: this.database, userService: this.userService });
                    this.authenticationService = new AuthenticationService({
                        database: this.database,
                        userService: this.userService,
                        sessionService: this.sessionService,
                    });

                    this.services = {};
                    this.services[ServiceManager.SERVICES.USER] = this.userService;
                    this.services[ServiceManager.SERVICES.AUTHENTICATION] = this.authenticationService;
                }

                async init() {
                    Promise.all([this.sessionService.init]);
                }

                get(serviceName) {
                    if (!Object.values(ServiceManager.SERVICES).includes(serviceName)) {
                        throw new Error('invalid serviceName');
                    }

                    return this.services[serviceName];
                }
            }

            class IService {
                constructor() {
                    if (new.target === IService) {
                        throw new Error('abstract');
                    }
                }
            }

            class UserService extends IService {
                constructor(dependency) {
                    super();

                    const { database } = dependency ?? {};

                    this.database = database;
                    this.hashAdapter = new JsShaAdapter();
                }

                async register(username, password) {
                    const userId = this._createUserId(username, password);
                    const newUser = new UserEntity(userId, { username });

                    const result = await this.database.update(Database.STORES.USER, newUser);

                    return newUser;
                }

                async isUser(username, password) {
                    const userId = this._createUserId(username, password);
                    const user = await this.database.select(Database.STORES.USER, userId);

                    return Boolean(user);
                }

                _createUserId(username, password) {
                    const text = `${username}:${password}`;
                    const hash = this.hashAdapter.sha256Hex(text);

                    return hash;
                }
            }

            class SessionService extends IService {
                constructor(dependency) {
                    super();

                    const { database, userService } = dependency ?? {};

                    this.database = database;
                    this.userService = userService;

                    this.session = null;
                }

                async init() {
                    const sessionId = utils.cookie.get(utils.cookie.KEYS.SESSION);

                    if (!sessionId) {
                        return;
                    }

                    const stored = await this.database.select(Database.STORES.SESSION, sessionId);

                    this.session = new SessionEntity(sessionId, stored);
                }

                get() {
                    return this.session;
                }
            }

            class AuthenticationService extends IService {
                constructor(dependency) {
                    super();

                    const { database, userService, sessionService } = dependency ?? {};

                    this.database = database;
                    this.userService = userService;
                    this.sessionService = sessionService;
                }

                isLogin() {
                    const session = this.sessionService.get();

                    if (session == null || !session.isValid(Date.now())) {
                        return false;
                    }

                    return true;
                }

                login(username, password) {
                    const isUser = this.userService.isUser(username, password);

                    if (!isUser) {
                        this.userService.register(username, password);
                    }

                    return true;
                }
            }

            class ViewManager {
                constructor(dependency) {
                    const { state, serviceManager } = dependency ?? {};

                    if (state == null || serviceManager == null) {
                        throw new Error('invalid dependency');
                    }

                    this.views = {};

                    this.views.loginView = new LoginView({ state, serviceManager, rootUpdate: this.update.bind(this) });
                }

                render() {
                    for (const view of Object.values(this.views)) {
                        view.render();
                    }
                }

                update() {}
            }

            class IView {
                constructor(dependency) {
                    if (new.target === IView) {
                        throw new Error('abstract');
                    }

                    const { state, serviceManager, rootUpdate } = dependency ?? {};

                    if (state == null || serviceManager == null || rootUpdate == null) {
                        throw new Error('invalid dependency');
                    }

                    this.state = state;
                    this.serviceManager = serviceManager;
                    this.rootUpdate = rootUpdate;
                }

                render() {
                    throw new Error('render required');
                }
            }

            class LoginView extends IView {
                constructor(dependency) {
                    super(dependency);

                    this.authenticationService = this.serviceManager.get(ServiceManager.SERVICES.AUTHENTICATION);

                    this.rootEl = document.querySelector('#login_view');
                    this.loginFormEl = document.querySelector('#login_form');

                    this.loginFormEl.addEventListener('submit', this._handleLogin.bind(this));
                }

                render() {
                    if (!this.state.isLogin) {
                        this.rootEl.classList.add('display');
                    }
                }

                _handleLogin(event) {
                    event.preventDefault();

                    const formData = new FormData(event.target);

                    const username = formData.get('username');
                    const password = formData.get('password');

                    const result = this.authenticationService.login(username, password);

                    if (result) {
                        this.state.isLogin = true;

                        this.rootUpdate();
                    } else {
                        alert('login failed');
                    }
                }
            }

            class DependencyManager {
                constructor() {
                    this._registry = new Map();
                }

                register(key, instance) {
                    this._registry.set(key, instance);
                }

                get(key) {
                    return this._registry.get(key);
                }
            }

            class App {
                constructor() {
                    this.deps = new DependencyManager();
                    this.database = new Database();
                    this.serviceManager = new ServiceManager({ database: this.database });
                    this.viewManager = new ViewManager({ state: this.state, serviceManager: this.serviceManager });
                }

                async run() {
                    await this._init();

                    await this._setup();

                    this.viewManager.render();
                }

                async _setup() {}

                async _setupInfrastructure() {
                    const db = new Database();
                    await db.init();

                    this.deps.register('config', { SESSION_KEY: 'wt_id', EXPIRES: 1800 });
                    this.deps.register('db', db);
                    this.deps.register('crypto', new JsShaAdapter());
                    this.deps.register('storage', new CookieAdapter());
                }

                async _init() {
                    await this.database.init();
                    await this.serviceManager.init();
                    this._initState();
                }

                _initState() {
                    const authenticationService = this.serviceManager.get(ServiceManager.SERVICES.AUTHENTICATION);

                    this.state.isLogin = authenticationService.isLogin();
                }
            }

            utils.cookie = {};

            utils.cookie.KEYS = {
                SESSION: 'work_tool_cookie',
            };

            utils.cookie.get = (name) => {
                if (typeof name !== 'string' || name.trim() === '') {
                    return null;
                }

                const encodedName = encodeURIComponent(name);
                const cookie = `; ${document.cookie}`;
                const value = cookie.split(`; ${encodedName}=`);

                if (value.length === 2) {
                    return decodeURIComponent(value[1].split(';')[0]);
                }

                return null;
            };

            // expires: seconds
            utils.cookie.set = (name, value, expires) => {
                if (typeof name !== 'string' || name.trim() === '') {
                    return;
                }

                if (value === null || value === undefined) {
                    return;
                }

                if (typeof expires !== 'number' || expires < 0) {
                    return;
                }

                const encodedName = encodeURIComponent(name);
                const encodedValue = encodeURIComponent(String(value));

                document.cookie = `${encodedName}=${encodedValue}; max-age=${expires}; path=/; Secure; SameSite=None`;
            };

            utils.encoding = {};

            utils.encoding.base32ToHex = (value) => {
                const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567';
                let bits = '';
                let hex = '';

                const normalized = value.replace(/=+$/g, '').toUpperCase();

                for (let i = 0; i < normalized.length; i++) {
                    const index = chars.indexOf(normalized[i]);

                    if (index === -1) {
                        return null;
                    }

                    bits += index.toString(2).padStart(5, '0');
                }

                for (let i = 0; i + 4 <= bits.length; i += 4) {
                    hex += parseInt(bits.slice(i, i + 4), 2).toString(16);
                }

                return hex;
            };

            class CookieAdapter {
                get(name) {
                    if (typeof name !== 'string' || name.trim() === '') {
                        return null;
                    }

                    const encodedName = encodeURIComponent(name);
                    const cookie = `; ${document.cookie}`;
                    const value = cookie.split(`; ${encodedName}=`);

                    if (value.length === 2) {
                        return decodeURIComponent(value[1].split(';')[0]);
                    }

                    return null;
                }

                set(name, value, expires) {
                    if (typeof name !== 'string' || name.trim() === '') {
                        return;
                    }

                    if (value === null || value === undefined) {
                        return;
                    }

                    if (typeof expires !== 'number' || expires < 0) {
                        return;
                    }

                    const encodedName = encodeURIComponent(name);
                    const encodedValue = encodeURIComponent(String(value));

                    document.cookie = `${encodedName}=${encodedValue}; max-age=${expires}; path=/; Secure; SameSite=None`;
                }
            }

            class JsShaAdapter {
                sha256Hex(text) {
                    const shaObj = new jsSHA('SHA-256', 'TEXT');

                    shaObj.update(text);

                    return shaObj.getHash('HEX');
                }
            }

            const app = new App();

            app.run();
        </script>
    </body>
</html>
